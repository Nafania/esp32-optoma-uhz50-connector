esphome:
  name: projector-connector
  friendly_name: projector-connector

  # https://esphome.io/components/esphome.html#esphome-on-boot
  # we don't know the power state of the projector right after the esp has booted
  # so our first job is to ask the projector
  # any changes in power state after this, the projector will broadcast automatically
  on_boot:
    # low priority means run late, we want to do this once everything is ready
    priority: -100
    then:
      # wait an extra five seconds to make sure projector is ready to answer us
      - delay: 5s
      - uart.write: [0x7E, 0x30, 0x30, 0x31, 0x32, 0x34, 0x20, 0x31, 0x0D]
      - delay: 5s
      - uart.write: [0x7E, 0x30, 0x30, 0x31, 0x32, 0x31, 0x20, 0x31, 0x0D]

# Use built-in ESPHome capabilities for reading UART          

esp32:
  board: esp32-s3-devkitc-1
  #board: m5stack-atoms3
  framework:
    type: arduino  

# Enable logging
logger:
  level: debug

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: !secret ap_ssid
    password: !secret ap_password

captive_portal:

uart:
  id: uart_bus
  rx_pin: GPIO5
  tx_pin: GPIO6
  baud_rate: 9600
  stop_bits: 1
  debug:
    direction: RX
    dummy_receiver: true
    after:
      delimiter: "\r"
    sequence:
      - lambda: |-
          std::string response = format_hex_pretty((uint8_t*)bytes.data(), bytes.size());
          ESP_LOGD("projector", "Received: %s", response.c_str());
          
          // Convert to string for processing
          std::string str_data(bytes.begin(), bytes.end());

          // Remove carriage return and newline characters
          str_data.erase(std::remove(str_data.begin(), str_data.end(), '\r'), str_data.end());
          str_data.erase(std::remove(str_data.begin(), str_data.end(), '\n'), str_data.end());
          
          // Force to uppercase
          std::transform(str_data.begin(), str_data.end(), str_data.begin(), ::toupper);
          
          // Process projector responses
          bool handled = false;
          
          // Command responses (P/F)
          if (str_data == "P" || str_data == "F") {
            id(waiting_for_command_response) = false;
            ESP_LOGD("projector", "command response received: %s", str_data.c_str());
            handled = true;
          }
          
          // Power status - handle both OK and Ok formats
          if (str_data == "OK1" || str_data == "Ok1" || str_data == "INFO1") {
            id(projector_power).publish_state(true);
            handled = true;
          }
          
          if (str_data == "OK0" || str_data == "Ok0" || str_data == "INFO2" || str_data == "INFO0") {
            id(projector_power).publish_state(false);
            handled = true;
          }
          
          // Only attempt to parse input source if NOT already handled as power
          // This prevents "Suffix after OK/Ok: '0'" logs when power is OFF
          if (!handled && (str_data.find("OK") != std::string::npos || str_data.find("Ok") != std::string::npos)) {
            
            // Extract everything after OK/Ok
            std::string suffix = "";
            if (str_data.find("OK") != std::string::npos) {
              suffix = str_data.substr(str_data.find("OK") + 2);
            } else if (str_data.find("Ok") != std::string::npos) {
              suffix = str_data.substr(str_data.find("Ok") + 2);
            }
            
            ESP_LOGD("projector", "Suffix after OK/Ok: '%s'", suffix.c_str());
            
             if (suffix == "9") {
               id(projector_source).publish_state("HDMI 3");
               handled = true;
             } else if (suffix == "8") {
               id(projector_source).publish_state("HDMI 2");
               handled = true;
             } else if (suffix == "7") {
               id(projector_source).publish_state("HDMI 1");
               handled = true;
             } else if (suffix == "C00?" || suffix == "C00") {
                // This seems to be the response when projector is OFF or searching
                ESP_LOGD("projector", "Projector reports searching/no signal or is OFF (code C00?)");
                handled = true;
             } else {
               // Only log as unknown if we haven't handled it as power status above (OK0/OK1)
               if (!handled) {
                 ESP_LOGD("projector", "UNKNOWN INPUT SOURCE CODE: '%s'", suffix.c_str());
                 ESP_LOGD("projector", "Known UHZ50 codes: 9=HDMI3, 8=HDMI2, 7=HDMI1");
               }
             }
          }
          
          if (!handled) {
            ESP_LOGD("projector", "unhandled message: %s", str_data.c_str());
          }  

# Docs source https://www.optomaeurope.com/ContentStorage/Documents/17f005d3-0d27-4822-b9f6-20f04085dbaf.pdf
# create a global flag we can use when we've sent a command (turn on / turn off)
# this may be used to ignore commands when one is queued already, this does not seem necessary in practice
globals:
- id: waiting_for_command_response
  type: bool
  restore_value: no
  initial_value: 'false'

# UART data processing now happens directly in the uart debug lambda above
# Empty text_sensor section for compatibility
text_sensor:

switch:
  - platform: template
    name: "Projector Power"
    icon: "mdi:projector"
    id: projector_power
    # Set to false to ensure UI reflects actual projector state from UART feedback
    optimistic: false

    turn_on_action:
      # first set the flag to denote we have a command response to wait for
      - globals.set:
          id: waiting_for_command_response
          value: 'true'
      # send the turn on command
      - uart.write: [0x7E, 0x30, 0x30, 0x30, 0x30, 0x20, 0x31, 0x0D]
      # Wait a bit for the projector to process and then query status to update UI
      - delay: 3s
      - uart.write: [0x7E, 0x30, 0x30, 0x31, 0x32, 0x34, 0x20, 0x31, 0x0D]
    
    turn_off_action:
      # first set the flag to denote we have a command response to wait for
      - globals.set:
          id: waiting_for_command_response
          value: 'true'
      # send the turn off command
      - uart.write: [0x7E, 0x30, 0x30, 0x30, 0x30, 0x20, 0x30, 0x0D]
      # Wait a bit for the projector to process and then query status to update UI
      - delay: 3s
      - uart.write: [0x7E, 0x30, 0x30, 0x31, 0x32, 0x34, 0x20, 0x31, 0x0D]

   # Experimental Mute Switch (Command ~0002 1/0 is standard, ~00140 1/0 for some models)
  - platform: template
    name: "Projector Mute"
    icon: "mdi:volume-off"
    id: projector_mute
    optimistic: true
    turn_on_action:
      - uart.write: [0x7E, 0x30, 0x30, 0x30, 0x32, 0x20, 0x31, 0x0D] # ~0002 1
    turn_off_action:
      - uart.write: [0x7E, 0x30, 0x30, 0x30, 0x32, 0x20, 0x30, 0x0D] # ~0002 0

select:
  - platform: template
    name: "Projector Source"
    icon: "mdi:video-input-hdmi"
    id: projector_source
    optimistic: false

    options:
     - "HDMI 1"
     - "HDMI 2"
     - "HDMI 3"
    
    set_action:
      then:
        - uart.write: !lambda |-
            std::string value = x;
            if (value == "HDMI 1") {
              return {0x7E, 0x30, 0x30, 0x31, 0x32, 0x20, 0x31, 0x0D};
            } else if (value == "HDMI 2") {
              return {0x7E, 0x30, 0x30, 0x31, 0x32, 0x20, 0x31, 0x35, 0x0D};
            } else if (value == "HDMI 3") {
              return {0x7E, 0x30, 0x30, 0x31, 0x32, 0x20, 0x31, 0x36, 0x0D};
            }
            // Fallback for unknown values
            return {0x7E, 0x30, 0x30, 0x31, 0x32, 0x20, 0x31, 0x0D};
        # Wait much longer for projector to switch and then query source for confirmation
        - delay: 5s
        - uart.write: [0x7E, 0x30, 0x30, 0x31, 0x32, 0x31, 0x20, 0x31, 0x0D]

  # Display Mode Select
  # Verified against Optoma UHZ50 Protocol Doc (17f005d3...) provided by user.
  # Command ~XX20 n (Write), ~XX123 1 (Read)
  - platform: template
    name: "Projector Display Mode"
    icon: "mdi:palette"
    id: projector_display_mode
    optimistic: true
    options:
      - "Presentation"
      - "Bright"
      - "Cinema"
      - "Game"
      - "sRGB"
      - "DICOM SIM."
      - "User"
      - "3D"
      - "User (3D)"
    set_action:
      - uart.write: !lambda |-
          std::string value = x;
          // Command ~XX20 n
          if (value == "Presentation") return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x31, 0x0D};      // ID 1
          if (value == "Bright")       return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x32, 0x0D};      // ID 2
          if (value == "Cinema")       return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x33, 0x0D};      // ID 3
          if (value == "Game")         return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x31, 0x32, 0x0D}; // ID 12
          if (value == "sRGB")         return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x34, 0x0D};      // ID 4
          if (value == "DICOM SIM.")   return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x31, 0x33, 0x0D}; // ID 13 (Wait, 13 is 3D in other list, checking table)
          // Table says: 13 = DICOM SIM (Wait, table says 13 in row 6? No, row 5 is 3D)
          // Let's re-read the table image carefully.
          // Level 4 column: Presentation (1), Bright (2), Cinema (3), Game (12), sRGB (4), DICOM SIM. (13), User (5), 3D (9), User(3D) (6).
          // Wait, the values in 'Set Para' column are: 1, 2, 3, 12, 4, 13, 5, 9, 6.
          
          if (value == "DICOM SIM.")   return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x31, 0x33, 0x0D}; // ID 13
          if (value == "User")         return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x35, 0x0D};      // ID 5
          if (value == "3D")           return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x39, 0x0D};      // ID 9
          if (value == "User (3D)")    return {0x7E, 0x30, 0x30, 0x32, 0x30, 0x20, 0x36, 0x0D};      // ID 6
          
          return {};

number:
  # Volume Control
  # Based on standard Optoma Command 03.
  - platform: template
    name: "Projector Volume"
    id: projector_volume
    icon: "mdi:volume-high"
    min_value: 0
    max_value: 100
    step: 1
    optimistic: true
    set_action:
      - uart.write: !lambda |-
          // Command ~0003 <n>
          // Convert number to string
          std::string val = std::to_string((int)x);
          std::vector<uint8_t> data = {0x7E, 0x30, 0x30, 0x30, 0x33, 0x20}; // Prefix ~0003_
          for (char c : val) {
            data.push_back(c);
          }
          data.push_back(0x0D); // CR
          return data;

interval:
# I set this up for 20 seconds as the Optoma projector seems to get a 
# bit confused when too many commands come in at once - and stops accepting
# remote (IR) and Serial commands until the power is reset.
# setting this for 20s reduces the chance of overlapping commands being sent
# when sennding power on/ off commands from home assistant.
  - interval: 20s
    then:
        # Query power status
      - uart.write: [0x7E, 0x30, 0x30, 0x31, 0x32, 0x34, 0x20, 0x31, 0x0D] 
        # Longer pause between commands - projector needs time
      - delay: 5s
        # Query input source (using 121 command for read)
      - uart.write: [0x7E, 0x30, 0x30, 0x31, 0x32, 0x31, 0x20, 0x31, 0x0D]
